import { allFields, replaceColors, replaceParams } from "../helpers/lottie.js";
import { deepClone } from "../helpers/utils.js";
import { loadIcon, loadLottieAnimation, registerIcon, registerLoader, registerTrigger, connectInstance, disconnectInstance, getIcon, getTrigger, } from "./manager.js";
const ELEMENT_STYLE = `
    :host {
      display: inline-flex;
      width: 32px;
      height: 32px;
      align-items: center;
      justify-content: center;
      position: relative;
      vertical-align: middle;
      fill: currentcolor;
      stroke: none;
      overflow: hidden;
    }

    :host(.inherit-color) svg path[fill] {
      fill: currentColor;
    }

    :host(.inherit-color) svg path[stroke] {
      stroke: currentColor;
    }

    svg {
        pointer-events: none;
        display: block;
    }

    div {    
        width: 100%;
        height: 100%;
    }

    div.slot {
        position: absolute;
        left: 0;
        top: 0;
        z-index: 2;
    }
`;
const OBSERVED_ATTRIBUTES = [
    "colors",
    "src",
    "icon",
    "trigger",
    "speed",
    "target",
    "stroke",
    "scale",
    "axis-x",
    "axis-y",
];
export class Element extends HTMLElement {
    constructor() {
        super();
        this.isReady = false;
        this.root = this.attachShadow({ mode: "open" });
    }
    /**
     * Register Lottie library.
     * @param loader Provide "loadAnimation" here from Lottie.
     */
    static registerLoader(loader) {
        registerLoader(loader);
    }
    /**
     * Register supported icon.
     * @param name
     * @param data
     */
    static registerIcon(name, data) {
        registerIcon(name, data);
    }
    /**
     * Register supported animation.
     * @param name
     * @param triggerClass
     */
    static registerTrigger(name, triggerClass) {
        registerTrigger(name, triggerClass);
    }
    /**
     * Element connected.
     */
    connectedCallback() {
        connectInstance(this);
        if (!this.isReady) {
            this.init();
        }
    }
    /**
     * Element disconnected.
     */
    disconnectedCallback() {
        this.unregisterLottie();
        disconnectInstance(this);
    }
    attributeChangedCallback(name, oldValue, newValue) {
        this[name] = newValue;
        if (name === 'axis-x') {
            this.axisXChanged();
        }
        else if (name === 'axis-y') {
            this.axisYChanged();
        }
        else {
            const method = this[`${name}Changed`];
            if (method) {
                method.call(this);
            }
        }
    }
    init() {
        if (this.isReady) {
            return;
        }
        this.isReady = true;
        const style = document.createElement("style");
        style.innerHTML = ELEMENT_STYLE;
        this.root.appendChild(style);
        const slotContainer = document.createElement("div");
        slotContainer.innerHTML = "<slot></slot>";
        slotContainer.classList.add("slot");
        this.root.appendChild(slotContainer);
        const container = document.createElement("div");
        this.root.appendChild(container);
        this.registerLottie();
    }
    registerLottie() {
        let iconData = this.iconData;
        if (!iconData) {
            return;
        }
        if (this.colors || this.stroke || this.scale || this['axis-x'] || this['axis-y']) {
            const fields = allFields(iconData);
            iconData = deepClone(iconData);
            if (this.colors) {
                replaceColors(iconData, fields, this.colors);
            }
            if (this.stroke) {
                replaceParams(iconData, fields, 'stroke', this.stroke);
            }
            if (this.scale) {
                replaceParams(iconData, fields, 'scale', this.scale);
            }
            if (this['axis-x']) {
                replaceParams(iconData, fields, 'axis', this['axis-x'], '0');
            }
            if (this['axis-y']) {
                replaceParams(iconData, fields, 'axis', this['axis-y'], '1');
            }
        }
        this.lottie = loadLottieAnimation({
            container: this.container,
            renderer: "svg",
            loop: false,
            autoplay: false,
            preserveAspectRatio: "xMidYMid meet",
            progressiveLoad: true,
            hideOnTransparent: false,
            animationData: iconData,
        });
        // set speed
        this.lottie.setSpeed(this.animationSpeed);
        // dispatch animation-complete
        this.lottie.addEventListener("complete", () => {
            this.dispatchEvent(new CustomEvent("animation-complete"));
        });
        this.triggerChanged();
    }
    unregisterLottie() {
        if (this.myConnectedTrigger) {
            this.myConnectedTrigger.disconnectedCallback();
            this.myConnectedTrigger = undefined;
        }
        if (this.lottie) {
            this.lottie.destroy();
            this.lottie = undefined;
            this.container.innerHTML = "";
        }
    }
    notify(name, from) {
        if (this[from] !== name) {
            return;
        }
        if (from === "icon") {
            if (this.lottie) {
                this.unregisterLottie();
            }
            this.registerLottie();
        }
        else if (from === "trigger" && !this.myConnectedTrigger) {
            this.triggerChanged();
        }
    }
    triggerChanged() {
        if (this.myConnectedTrigger) {
            this.myConnectedTrigger.disconnectedCallback();
            this.myConnectedTrigger = undefined;
        }
        if (this.trigger && this.lottie) {
            const TriggerClass = getTrigger(this.trigger);
            if (TriggerClass) {
                // find target event listener
                const target = this.target ? this.closest(this.target) : null;
                this.myConnectedTrigger = new TriggerClass(this, target || this, this.lottie);
                this.myConnectedTrigger.connectedCallback();
            }
        }
    }
    colorsChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    strokeChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    scaleChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    axisXChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    axisYChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    speedChanged() {
        if (this.lottie) {
            this.lottie.setSpeed(this.animationSpeed);
        }
    }
    iconChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    async srcChanged() {
        if (this.src) {
            await loadIcon(this.src);
        }
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    /**
     * Acces icon data for this element.
     */
    get iconData() {
        if (this.icon && typeof this.icon === "object") {
            return this.icon;
        }
        return getIcon(this.icon || this.src);
    }
    /**
     * Access current trigger instance.
     */
    get connectedTrigger() {
        return this.myConnectedTrigger;
    }
    get container() {
        return this.root.lastElementChild;
    }
    get animationSpeed() {
        return this.speed ? parseFloat(this.speed) || 1 : 1;
    }
    static get observedAttributes() {
        return OBSERVED_ATTRIBUTES;
    }
}
//# sourceMappingURL=element.js.map